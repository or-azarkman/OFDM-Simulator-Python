"""
transmitter.py

Transmitter chain for an OFDM system:
- Bit generation
- QPSK modulation with Gray coding
- Subcarrier mapping
- OFDM IFFT and cyclic prefix insertion

Mathematical Background (described in docstrings below):
    * OFDM IFFT formula
    * Cyclic prefix construction
    * QPSK symbol mapping

Future extension points include:
- Pilot insertion
- Null carriers and guard bands
- Support for additional modulation schemes (e.g., 16-QAM)
"""

import numpy as np

def generate_random_bits(num_bits: int) -> np.ndarray:
    """
    Generate a random bit array of 0s and 1s.

    Args:
        num_bits (int): Number of bits to generate.

    Returns:
        np.ndarray: Array of shape (num_bits,) with bits {0,1}.
    """
    return np.random.randint(0, 2, num_bits)


def qpsk_modulate(bits: np.ndarray) -> np.ndarray:
    """
    Map bits to QPSK symbols using Gray coding.

    QPSK modulation mapping (normalized):
        s[k] = (1/sqrt(2)) * ( (2*b0 - 1) + j*(2*b1 - 1) )

    Here, each pair of bits [b0,b1] is mapped as:
        00 ->  1 + 1j
        01 -> -1 + 1j
        11 -> -1 - 1j
        10 ->  1 - 1j

    The 1/sqrt(2) normalizes the symbol energy.

    Args:
        bits (np.ndarray): 1D array of bits of length divisible by 2.

    Returns:
        np.ndarray: Complex QPSK symbols of length len(bits)/2.
    """
    if len(bits) % 2 != 0:
        raise ValueError("Number of bits must be even for QPSK.")

    bits = bits.reshape(-1, 2)
    mapping = {
        (0, 0):  1 + 1j,
        (0, 1): -1 + 1j,
        (1, 1): -1 - 1j,
        (1, 0):  1 - 1j,
    }
    symbols = np.array([mapping[tuple(b)] for b in bits], dtype=complex)
    symbols /= np.sqrt(2)  # Normalization
    return symbols


def map_to_subcarriers(symbols: np.ndarray, fft_size: int) -> np.ndarray:
    """
    Map data symbols into the OFDM subcarrier array.

    A simple mapping places the symbols in the first positions of length fft_size:
        X[k] = d[k] for k < len(symbols)
        X[k] = 0 otherwise

    Mathematically:
        X = [d0, d1, ..., dM-1, 0, ..., 0],
        where M = len(symbols) <= fft_size.

    Args:
        symbols (np.ndarray): Symbols to place on subcarriers.
        fft_size (int): Total number of subcarriers (FFT size).

    Returns:
        np.ndarray: Frequency-domain frame of length fft_size.
    """
    if len(symbols) > fft_size:
        raise ValueError("More symbols than available subcarriers.")

    frame = np.zeros(fft_size, dtype=complex)
    frame[:len(symbols)] = symbols
    return frame


def ofdm_ifft(frame: np.ndarray) -> np.ndarray:
    """
    Perform the Inverse FFT (IFFT) on frequency-domain subcarrier frame.

    The OFDM time-domain signal x[n] is generated by the IFFT:
        x[n] = (1/N) sum_{k=0}^{N-1} X[k] * exp(j*2*pi*k*n/N),
    where N = fft_size and X are the subcarrier symbols.

    Args:
        frame (np.ndarray): Frequency-domain samples (length = fft_size).

    Returns:
        np.ndarray: Time-domain OFDM samples.
    """
    return np.fft.ifft(frame)


def add_cyclic_prefix(time_signal: np.ndarray, cp_len: int) -> np.ndarray:
    """
    Add cyclic prefix to a time-domain OFDM symbol.

    The cyclic prefix of length cp_len is taken from the end of the IFFT
    symbol and prepended to the beginning:
        x_cp[n] = x[N - cp_len + n], n=0...cp_len-1
    The transmitted OFDM symbol becomes:
        [x_cp, x]

    Args:
        time_signal (np.ndarray): OFDM time-domain samples.
        cp_len (int): Cyclic prefix length.

    Returns:
        np.ndarray: OFDM symbol with cyclic prefix.
    """
    cp = time_signal[-cp_len:]
    return np.concatenate([cp, time_signal])


def generate_ofdm_symbol(
    bits: np.ndarray,
    fft_size: int,
    cp_len: int
) -> np.ndarray:
    """
    Create one OFDM symbol (with cyclic prefix) from input bits.

    This function chains:
      1) QPSK modulation
      2) Subcarrier mapping
      3) IFFT
      4) Cyclic prefix insertion

    Args:
        bits (np.ndarray): Input bits for one OFDM symbol.
        fft_size (int): FFT size / number of subcarriers.
        cp_len (int): Cyclic prefix length.

    Returns:
        np.ndarray: Time-domain OFDM symbol with cyclic prefix.
    """
    # Step 1: Modulate bits
    qpsk_syms = qpsk_modulate(bits)

    # Step 2: Map to subcarriers
    freq_frame = map_to_subcarriers(qpsk_syms, fft_size)

    # Step 3: IFFT (time-domain conversion)
    time_signal = ofdm_ifft(freq_frame)

    # Step 4: Add cyclic prefix
    tx_symbol = add_cyclic_prefix(time_signal, cp_len)
    return tx_symbol


def generate_ofdm_stream(
    bits: np.ndarray,
    fft_size: int,
    cp_len: int
) -> np.ndarray:
    """
    Convert a full bitstream into multiple OFDM symbols.

    If bitstream length isn't an exact multiple of bits_per_symbol,
    this function will raise a ValueError.

    Args:
        bits (np.ndarray): Full bitstream (length = num_symbols * bits_per_symbol).
        fft_size (int): FFT size.
        cp_len (int): Cyclic prefix length.

    Returns:
        np.ndarray: 2D array: [num_symbols, symbol_length_with_cp]
    """
    bits_per_symbol = fft_size * 2  # QPSK: 2 bits per subcarrier
    if len(bits) % bits_per_symbol != 0:
        raise ValueError("Bitstream must be multiple of bits_per_symbol.")

    ofdm_symbols = []
    for i in range(len(bits) // bits_per_symbol):
        start = i * bits_per_symbol
        symbol_bits = bits[start : start + bits_per_symbol]
        ofdm_sym = generate_ofdm_symbol(symbol_bits, fft_size, cp_len)
        ofdm_symbols.append(ofdm_sym)

    return np.array(ofdm_symbols)
